### 装饰者模式
> 给爱用继承的人一个全新的设计眼界
---
####开闭原则的使用：
> 每个地方都采用开放-关闭原则，是一种浪费，也没必要，还会导致代码变得复杂且难以理解
---

####装饰者模式特点：
* 装饰者和被装饰对象有相同都超类型
* 你可以用一个或多个装饰者包装一个对象
* 既然装饰者和被装饰对象有相同超类型，所以再任何需要原始对象（被包装的）的场合，可以用装饰过的对象代替它
* 装饰者可以在所委托被装饰者的行为之前与/或之后，加上自己的行为，以达到特定的目的
* 对象可以在任何时候被装饰，所以可以在运行时动态地、不限量地用你喜欢的装饰者来装饰对象。
---

####关键：
> 装饰者和被装饰的对象必须是一样的类型，也就是有共同的超类，这是相当关键的地方，在这里可以利用继承达到类型匹配，而不是利用继承获得"行为"

---

####缺点：
> 利用装饰者模式，常常造成设计中有大量的小类，数量实在太多，可能会造成此API程序员的困扰

---

####问题：
> 采用装饰者在实例化组件时，将增加代码的复杂度。一旦使用装饰者模式，不只需要实例化组件，还要把此组件包装进装饰者中，天晓得有几个

####解决：
> 工厂模式（Factory）和生成器模式(Builder)对这个问题会很有帮助
---

####JDK中的装饰则模式
* IO流，FilterInputStream是装饰者

